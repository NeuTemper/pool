## 块级绑定

- let: 将代码作用域限制在当前代码块中，不会变量提升
- const: 与`let`不同在于其职能为声明为常量，`const`不能再次被赋值

> 暂时性死区(temporal dead zone): 使用`let`或者`const`的变量，在到达声明之前是无法被访问的，试图访问会返回一个引用错误。当js引擎检视接下来的代码块并发现变量声明时，面对`var`会将其放在作用域顶部，而面对`let`或者`const`会将声明放在暂时性死区内，只有执行到变量的声明语句时，变量从暂时性死区中移除并才可以安全使用。

#### 循环内的函数

`var`在循环以外可以被访问，所以循环内创建函数是一种有问题的情况。
```javascript
var funcs = [];

for(var i = 0; i < 10; i++) {
    funcs.push(() => { console.log(i); })
}

// 输出10个10, 因为函数取的是对i的引用，此时i为10
funcs.forEach((val) => { val(); }); 
```

之前可以利用IIFE来解决这个问题，传入变量的方式使得其每次都创建一个i的副本。

```javascript
for(var i = 10; i < 10; i++) {
    funcs.push((function(key) {
        console.log(key);
    }(i)));
}
```

使用`let`或者`const`来解决，在每个作用域会形成一个新的i变量

```javascript
for(let i = 10; i < 10; i++) {
    funcs.push((i) => { console.log(i); });
}
```

#### 循环常量声明

对于以下例子，原因是`const`在进行`for-in`或者`for-of`循环中，每次迭代创建了一个新的变量绑定，而不是去修改已经绑定的值

```javascript
// 第一次迭代成功执行，之后报错，因为修改了const的值
for(const i = 0; i < 10; i++) {
    console.log(i);
}

// 而在for-in或者for-of循环中，const与let作用相同，不会报错
for(const key in obj) {
    console.log(key);
}
```

#### 全局对象
`let`与`var`不同的一点也在于其全局变量的表现，如果使用`var`的话，会在其全局作用域声明一个变量并且将其绑定在全局对象上，但是如果是`let`或者`const`话，虽然会在全局作用域上创建新的绑定，但是无法将对象绑定在全局对象上，而只能进行屏蔽。

```javascript
var RegExp = 1; 

console.log(RegExp); // 1
window.RegExp == RegExp; // true

let RegExp = 1;
console.log(RegExp); // 1
window.RegExp == RegExp; // false
```

#### 总结

对于ES6的应用中，一种比较流行的方案是，默认情况下变量的声明应该使用`const`，大部分的变量在初始化的过程后并不会被修改。而对于需要被重复修改的变量，应该使用`let`代替。这有助于在代码中确保基本层次的不可变性，而防止某种类型的错误。